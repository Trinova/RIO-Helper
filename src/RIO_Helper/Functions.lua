---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by PanzerbÃ¼chse-Blackrock.
--- DateTime: 09-Apr-22 15:57
---
local AddonName, PrivateVariables = ...;
local DungeonBaseScores = PrivateVariables.Data.DungeonBaseScores;
local TimerConstants = PrivateVariables.Data.TimerConstants;

-- General functions
---@param num number
---@return number
local function round (num)
    return num >= 0 and math.floor(num + 0.5) or math.ceil(num - 0.5)
end

--- Creates a shallow copy of the given table or value
---@param orig any
---@return any
local function shallowCopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in pairs(orig) do
            copy[orig_key] = orig_value
        end
    else
        -- number, string, boolean, etc
        copy = orig
    end
    return copy
end
local function coerce(value, default)
    return value and value or default
end
-- Presentation functions
---@param num number
---@param precision number
---@param num boolean
---@return string
local function formatNumber(num, precision, noPrefix)
    if num == nil then
        return "nil"
    end
    local formatString = "%." .. precision .. "f"
    local absolutValueString = string.format(formatString, num)
    if noPrefix then
        return num < 0 and strsub(absolutValueString, 1) or absolutValueString
    else
        return (num > 0 and "+" or "") .. absolutValueString
    end
end

--- left pads the string up to the given length
---@param str string
---@param length number
---@return string
local function leftPadString(str, length)
    local result = str .. ""
    while strlen(result) < length do
        result = " " .. result
    end
    return result
end

-- WoW Functions
---@param affixScoreData {baseScore: number, timeBonus: number}
---@return number
local function computeKeyBaseScore(affixScoreData)
    return affixScoreData and affixScoreData.baseScore + affixScoreData.timeBonus or 0
end

---@param score1 number
---@param score2 number
---@return number
local function computeAffixScoreSum(score1, score2)
    return max(score1, score2) * 1.5 + min(score1, score2) * 0.5;
end

---@param timeInSeconds number
---@param parTime number
---@return number
local function computeTimeModifier(timeInSeconds, parTime)
    -- if we took 130% time this is -30% (30% too slow)
    local percentageOffset = (1 - timeInSeconds / parTime)
    -- the bonus is capped at being 40% faster than par time
    local cappedPercentageOffset = percentageOffset > TimerConstants.Threshold and TimerConstants.Threshold or percentageOffset
    local linearScaledTimeBonus = cappedPercentageOffset * TimerConstants.MaxModifier / TimerConstants.Threshold

    if percentageOffset >= 0 then
        -- bonus is interpolated linear between 60% and 100% par time
        return linearScaledTimeBonus;
    elseif percentageOffset >= -TimerConstants.Threshold then
        -- bonus is interpolated linear between 100% and 140% par time
        return linearScaledTimeBonus - TimerConstants.KeyDepletionMalus;
    else
        -- key is hard set to 0 points if slower than 140% par time, `nil` indicates this
        return nil;
    end
end

---@param dungeonId number
---@param level number
---@param timeInSeconds number
---@return {score: number, baseScore: number, timeBonus: number, parTimePercentage: number}
local function computeScores(dungeonId, level, timeInSeconds, debug)
    local _, _, parTime, _, _ = C_ChallengeMode.GetMapUIInfo(dungeonId)

    if debug then
        print("====computeScores====")
        print("dungeonId :"..dungeonId)
        print("level :"..level)
        print("timeInSeconds :"..timeInSeconds)
    end

    local baseScore = DungeonBaseScores[math.min(level, 10)] + max(0, level - 10) * 5;
    local timeScore = computeTimeModifier(timeInSeconds, parTime);
    if debug then
        print("baseScore :"..baseScore)
        print("timeScore :"..timeScore)
    end
    return {
        score = timeScore and baseScore + timeScore or 0,
        baseScore = timeScore and baseScore or 0,
        timeBonus = timeScore and timeScore or 0,
        parTimePercentage = 100 * timeInSeconds / parTime
    }
end

PrivateVariables.Functions = {
    round = round,
    shallowCopy = shallowCopy,
    formatNumber = formatNumber,
    leftPadString = leftPadString,
    computeKeyBaseScore = computeKeyBaseScore,
    computeAffixScoreSum = computeAffixScoreSum,
    computeScores = computeScores,
    coerce = coerce,
}